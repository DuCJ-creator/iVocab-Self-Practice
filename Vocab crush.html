<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vocab Crush</title>
  <!-- PapaParse CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Arial', sans-serif;
      background:#1a1a2e;
      color:#eee;
      user-select:none;
      height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding:1rem;
      overflow:hidden;
    }
    .container { max-width:90vw; width:100%; text-align:center; }
    .selector, .game-over {
      background:#16213e;
      padding:1.5rem;
      border-radius:16px;
      margin:1rem 0;
      max-width:90vw;
    }
    .unit-group, .time-group {
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
      gap:0.5rem;
      margin-top:1rem;
    }
    .btn {
      padding:0.8rem 1rem;
      background:#0f3460;
      color:white;
      border:none;
      border-radius:8px;
      font-size:1rem;
      cursor:pointer;
      transition:0.2s;
      touch-action:manipulation;
    }
    .btn:hover { background:#1a5fb4; }
    .btn:active { transform:scale(0.95); }
    .btn.active { background:#00ff88; color:black; }
    .btn.danger { background:#ff4444; }
    .btn.big { padding:1rem 2rem; font-size:1.2rem; background:#ff0; color:black; }

    .board {
      display:grid;
      grid-template-columns:repeat(6,1fr);
      gap:8px;
      max-width:90vw;
      width:100%;
      aspect-ratio:1;
      margin:1rem auto;
    }
    .tile {
      background:#16213e;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:clamp(0.7rem,2.3vw,1.1rem);
      font-weight:bold;
      cursor:pointer;
      transition:all 0.3s ease;
      box-shadow:0 4px 8px rgba(0,0,0,0.3);
      position:relative;
      overflow:hidden;
      min-height:0;
    }
    .tile.selected {
      transform:scale(0.95);
      box-shadow:0 0 20px #00ff88;
      z-index:10;
    }
    .tile.match { animation:pop 0.4s ease forwards; background:#00ff88 !important; color:black; }
    .tile.wrong { animation:shake 0.4s ease; background:#ff4444 !important; }
    .tile.drop { animation:dropAnim 0.5s ease; }

    @keyframes pop {
      0%{transform:scale(1)}
      50%{transform:scale(1.3)}
      100%{transform:scale(0);opacity:0}
    }
    @keyframes shake {
      0%,100%{transform:translateX(0)}
      25%{transform:translateX(-8px)}
      75%{transform:translateX(8px)}
    }
    @keyframes dropAnim {
      0%{transform:translateY(-100%);opacity:0}
      100%{transform:translateY(0);opacity:1}
    }
    @keyframes pulse {
      0%,100%{opacity:1}
      50%{opacity:0.5}
    }

    /* ä¸Šæ–¹ HUD å€å¡Šï¼šè¨ˆæ™‚ + è¨ˆåˆ† */
    .hud {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:1rem;
      margin-top:0.5rem;
      padding:0.4rem 0.8rem;
      background:#0f1930;
      border-radius:10px;
    }
    .timer {
      font-size:1.4rem;
      font-weight:bold;
      color:#fff;
    }
    .timer.warning { color:#ff0; animation:pulse 1s infinite; }
    .timer.danger { color:#ff4444; animation:pulse 0.5s infinite; }

    .score-box {
      font-size:1.4rem;
      font-weight:bold;
      color:#00ff88;
      text-align:right;
    }
    .score-label {
      font-size:0.9rem;
      display:block;
      color:#aaa;
    }

    /* åˆ†æ•¸å¢æ¸›æç¤º +10 / -10 */
    .score-delta {
      font-size:0.9rem;
      min-height:1.1rem;
      display:block;
      opacity:0;
    }
    .score-delta.show.gain {
      color:#00ff88;
      animation:scoreFade 0.8s ease;
      opacity:1;
    }
    .score-delta.show.loss {
      color:#ff4444;
      animation:scoreFade 0.8s ease;
      opacity:1;
    }
    @keyframes scoreFade {
      0%   { opacity:1; transform:translateY(0); }
      100% { opacity:0; transform:translateY(-6px); }
    }

    .combo { color:#ff0; font-size:1.2rem; margin:0.5rem 0; }

    .back-btn {
      position:absolute;
      top:10px;
      left:10px;
      z-index:100;
    }
    .loading { text-align:center; color:#00ff88; font-size:1.2rem; }
    .stats { margin:1rem 0; font-size:1.1rem; }
    .stats span { display:block; margin:0.5rem 0; }
    h1 { font-size:2.2rem; margin-bottom:1rem; color:#00ff88; }
    h2 { margin-bottom:1rem; }

    /* ğŸ’— / ğŸ· ä¸­å¤®å‹•ç•«æç¤º */
    .feedback {
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%) scale(0.5);
      font-size:3rem;
      opacity:0;
      pointer-events:none;
      z-index:200;
      transition:transform 0.25s ease, opacity 0.25s ease;
    }
    .feedback.show {
      opacity:1;
      transform:translate(-50%,-50%) scale(1.1);
    }
    .feedback.correct { text-shadow:0 0 20px #ff69b4; }
    .feedback.wrong  { text-shadow:0 0 20px #ff4444; }
  </style>
</head>
<body>
  <div id="app" class="container"></div>

  <script>
    // éŸ³æ•ˆ
    const sounds = {
      match: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      wrong: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      drop: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      combo: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      countdown: new Audio('data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAA')
    };
    Object.values(sounds).forEach(s => s.volume = 0.5);

    // å…¨åŸŸè®Šæ•¸
    let currentLevel, currentUnitStart, selectedTime = 180;
    let board = [], selected = [], score = 0, combo = 0, correctCount = 0, wrongCount = 0;
    let timeLeft = selectedTime, timerId = null, gameActive = false;
    const GRID_SIZE = 6;
    const TIME_OPTIONS = { 180: '3åˆ†é˜', 300: '5åˆ†é˜', 600: '10åˆ†é˜' };
    const CSV_URLS = Array.from({length:6}, (_,i) => `https://raw.githubusercontent.com/DuCJ-creator/iVocab-Self-Practice/main/level${i+1}.csv`);

    const app = document.getElementById('app');

    // è¼‰å…¥ CSV
    async function loadCSV(level) {
      return new Promise((resolve) => {
        Papa.parse(CSV_URLS[level-1], {
          download: true,
          header: true,
          complete: (results) => {
            const data = results.data
              .filter(r => r.Level && r.Unit && r.Word && r['Chinese Meaning'])
              .map(r => ({
                level: parseInt(r.Level),
                unit: parseInt(r.Unit),
                word: r.Word.trim(),
                meaning: r['Chinese Meaning'].replace(/;/g, 'ï¼›').trim()
              }));
            resolve(data);
          },
          error: () => { alert('è¼‰å…¥å¤±æ•—'); resolve([]); }
        });
      });
    }

    // ç”Ÿæˆ 18 å°
    function generatePool(words) {
      const picked = [];
      while (picked.length < 18) {
        const rand = words[Math.floor(Math.random() * words.length)];
        if (rand.word && rand.meaning) picked.push(rand);
      }
      const wordTiles = picked.map(w => ({ text: w.word, type: 'word', pair: w.meaning }));
      const meaningTiles = picked.map(w => ({ text: w.meaning, type: 'meaning', pair: w.word }));
      return [...wordTiles, ...meaningTiles].sort(() => Math.random() - 0.5);
    }

    // å»ºç«‹æ£‹ç›¤
    function createBoard(pool) {
      const grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      let idx = 0;
      for (let r = 0; r < GRID_SIZE && idx < pool.length; r++) {
        for (let c = 0; c < GRID_SIZE && idx < pool.length; c++) {
          grid[r][c] = { ...pool[idx++], row: r, col: c };
        }
      }
      return grid;
    }

    // æ‰è½é‚è¼¯ï¼ˆæ¯åˆ—å¾ä¸Šå¾€ä¸‹ï¼‰
    function dropTiles() {
      const newBoard = board.map(row => [...row]);
      for (let c = 0; c < GRID_SIZE; c++) {
        let writePos = GRID_SIZE - 1;
        for (let r = GRID_SIZE - 1; r >= 0; r--) {
          if (newBoard[r][c]) {
            if (r !== writePos) {
              newBoard[writePos][c] = { ...newBoard[r][c], row: writePos };
              newBoard[r][c] = null;
            }
            writePos--;
          }
        }
      }
      return newBoard;
    }

    // ä¸­å¤®å‹•ç•«æç¤ºï¼šğŸ’— / ğŸ·
    function showFeedback(type) {
      const fb = document.getElementById('feedback');
      if (!fb) return;
      if (type === 'correct') {
        fb.textContent = 'ğŸ’—ğŸ’—';
        fb.className = 'feedback show correct';
      } else {
        fb.textContent = 'ğŸ·ğŸ·';
        fb.className = 'feedback show wrong';
      }
      setTimeout(() => {
        const fb2 = document.getElementById('feedback');
        if (fb2) fb2.className = 'feedback';
      }, 450);
    }

    // æ›´æ–°åˆ†æ•¸é¡¯ç¤ºï¼ˆç¸½åˆ† + é€™ä¸€æ‰‹ + / - å¹¾åˆ†ï¼‰
    function updateScoreDisplay(delta) {
      const scoreEl = document.getElementById('scoreVal');
      const deltaEl = document.getElementById('scoreDelta');
      if (scoreEl) scoreEl.textContent = score;

      if (!deltaEl) return;

      if (!delta) {
        deltaEl.textContent = '';
        deltaEl.className = 'score-delta';
        return;
      }
      deltaEl.textContent = (delta > 0 ? '+' : '') + delta;
      deltaEl.className = 'score-delta show ' + (delta > 0 ? 'gain' : 'loss');

      setTimeout(() => {
        const d = document.getElementById('scoreDelta');
        if (d) d.className = 'score-delta';
      }, 800);
    }

    // é»æ“Šå–®ä¸€æ ¼å­
    function handleTileClick(r, c) {
      if (!gameActive) return;
      const t = board[r][c];
      if (!t) return;
      if (selected.length >= 2) return;
      if (selected.some(s => s.row === r && s.col === c)) return;

      selected.push({ row: r, col: c, ...t });
      renderBoard();
      if (selected.length === 2) {
        setTimeout(checkMatch, 300);
      }
    }

    // æ¸²æŸ“æ£‹ç›¤èˆ‡ HUD
    function renderBoard() {
      let html = `
        <button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="hud">
          <div class="timer">æ™‚é–“: --:--</div>
          <div class="score-box">
            <span class="score-label">å¾—åˆ†</span>
            <span id="scoreVal">${score}</span>
            <span id="scoreDelta" class="score-delta"></span>
          </div>
        </div>
        ${combo > 0 ? `<div class="combo">Combo x${Math.floor(combo/3)+1}</div>` : ''}
        <div class="board" id="gameBoard">`;

      board.forEach((row, r) => {
        row.forEach((tile, c) => {
          if (!tile) {
            html += `<div class="tile" style="visibility:hidden"></div>`;
          } else {
            const isSel = selected.some(s => s.row === r && s.col === c);
            html += `<div class="tile ${isSel ? 'selected' : ''}" data-r="${r}" data-c="${c}" onclick="handleTileClick(${r},${c})">${tile.text}</div>`;
          }
        });
      });

      html += `</div>
        <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:0.5rem;">
          <button class="btn" onclick="resetGame()">é‡ç½®</button>
          <button class="btn danger" onclick="quitGame()">çµæŸ</button>
        </div>
        <div id="feedback" class="feedback"></div>`;

      app.innerHTML = html;
      updateTimerDisplay();
      // åˆæ¬¡æ¸²æŸ“æ™‚æ¸…ç©ºä¸€æ¬¡ delta é¡¯ç¤º
      updateScoreDisplay(0);
    }

    // æª¢æŸ¥é…å°
    function checkMatch() {
      if (selected.length < 2) return;
      const [a, b] = selected;
      let delta = 0;

      const correct =
        (a.type === 'word' && a.pair === b.text) ||
        (b.type === 'word' && b.pair === a.text);

      if (correct) {
        correctCount++;
        sounds.match.play();
        showFeedback('correct');

        const baseCombo = Math.floor(combo / 3) + 1;
        delta = 10 * baseCombo;
        score += delta;
        if (combo % 3 === 0) sounds.combo.play();
        combo++;

        // ç§»é™¤æ­£ç¢ºé‚£ä¸€å°
        board[a.row][a.col] = null;
        board[b.row][b.col] = null;
        selected = [];

        setTimeout(() => {
          sounds.drop.play();
          board = dropTiles();
          renderBoard();
          updateScoreDisplay(delta);
          if (board.flat().every(t => !t)) endGame('å…¨æ¶ˆï¼');
        }, 300);
      } else {
        wrongCount++;
        sounds.wrong.play();
        showFeedback('wrong');

        const baseCombo = Math.floor(Math.abs(combo) / 3) + 1;
        delta = -10 * baseCombo;
        score = Math.max(0, score + delta);
        combo = 0;

        setTimeout(() => {
          selected = [];
          renderBoard();
          updateScoreDisplay(delta);
        }, 600);
      }

      if (score <= 0) {
        setTimeout(() => endGame('åˆ†æ•¸æ­¸é›¶'), 800);
      }
    }

    // è¨ˆæ™‚
    function startTimer() {
      gameActive = true;
      timeLeft = Number(selectedTime);
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          endGame();
        } else if (timeLeft <= 10) {
          sounds.countdown.play();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const el = app.querySelector('.timer');
      if (!el) return;
      const m = String(Math.floor(timeLeft/60)).padStart(2,'0');
      const s = String(timeLeft%60).padStart(2,'0');
      el.textContent = `æ™‚é–“: ${m}:${s}`;
      el.className = 'timer';
      if (timeLeft <= 10) el.classList.add('danger');
      else if (timeLeft <= 30) el.classList.add('warning');
    }

    // çµæŸ
    function endGame(reason = 'æ™‚é–“åˆ°') {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      const acc = correctCount + wrongCount > 0 ? Math.round(correctCount/(correctCount+wrongCount)*100) : 0;
      const maxCombo = combo > 0 ? Math.floor(combo/3)+1 : 1;

      app.innerHTML = `
        <div class="game-over">
          <h1>Game Over! (${reason})</h1>
          <div class="stats">
            <span class="score">æœ€çµ‚å¾—åˆ†: ${score}</span>
            <span>æ­£ç¢º: ${correctCount} æ¬¡</span>
            <span>éŒ¯èª¤: ${wrongCount} æ¬¡</span>
            <span>æ­£ç¢ºç‡: ${acc}%</span>
            <span>æœ€é«˜é€£æ“Š: x${maxCombo}</span>
          </div>
          <button class="btn big" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
          <button class="btn" onclick="renderLevelSelector()">é¸å–®</button>
        </div>`;
    }

    function quitGame() { if (confirm('æå‰çµæŸï¼Ÿ')) endGame('æ‰‹å‹•çµæŸ'); }

    function resetGame() {
      if (!currentLevel || !currentUnitStart) {
        renderLevelSelector();
        return;
      }
      if (timerId) clearInterval(timerId);
      initGame(currentLevel, currentUnitStart);
    }

    // åˆå§‹åŒ–éŠæˆ²
    async function initGame(level, unitStart) {
      app.innerHTML = '<div class="loading">è¼‰å…¥ä¸­...</div>';
      const data = await loadCSV(level);
      const units = data.filter(d => d.unit >= unitStart && d.unit <= unitStart + 4);
      if (units.length < 18) {
        alert('å–®å­—ä¸è¶³ï¼');
        renderUnitSelector();
        return;
      }
      const pool = generatePool(units);
      board = createBoard(pool);
      selected = [];
      score = 0;
      combo = 0;
      correctCount = 0;
      wrongCount = 0;
      renderBoard();
      startTimer();
    }

    // é¸å–®
    function renderLevelSelector() {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      app.innerHTML = `<div class="selector"><h2>é¸æ“‡ Level</h2><div class="unit-group">
        ${[1,2,3,4,5,6].map(l=>`<button class="btn" onclick="currentLevel=${l};renderTimeSelector()">Level ${l}</button>`).join('')}
      </div></div>`;
    }

    function renderTimeSelector() {
      app.innerHTML = `<button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="selector"><h2>é¸æ“‡æ™‚é–“</h2><div class="time-group">
        ${Object.entries(TIME_OPTIONS).map(([s,l])=>`<button class="btn ${selectedTime==s?'active':''}" onclick="selectedTime=${s};renderUnitSelector()">${l}</button>`).join('')}
      </div></div>`;
    }

    function renderUnitSelector() {
      const groups = [];
      for (let i=1; i<=50; i+=5) groups.push({start:i, end:Math.min(i+4,50)});
      app.innerHTML = `<button class="btn back-btn" onclick="renderTimeSelector()">è¿”å›</button>
        <div class="selector"><h2>Level ${currentLevel} - é¸æ“‡ Unit</h2><div class="unit-group">
        ${groups.map(g=>`<button class="btn" onclick="currentUnitStart=${g.start};initGame(currentLevel,${g.start})">${g.start}â€“${g.end}</button>`).join('')}
      </div></div>`;
    }

    // å•Ÿå‹•
    renderLevelSelector();
  </script>
</body>
</html>
