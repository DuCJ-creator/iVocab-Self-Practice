<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vocab Crush</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: #1a1a2e; color: #eee; user-select: none; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; overflow: hidden; }
    .container { max-width: 90vw; width: 100%; text-align: center; }
    .selector, .game-over { background: #16213e; padding: 1.5rem; border-radius: 16px; margin: 1rem 0; max-width: 90vw; }
    .unit-group, .time-group { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; margin-top: 1rem; }
    .btn { padding: 0.8rem 1rem; background: #0f3460; color: white; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: 0.2s; touch-action: manipulation; }
    .btn:hover { background: #1a5fb4; }
    .btn:active { transform: scale(0.95); }
    .btn.active { background: #00ff88; color: black; }
    .btn.danger { background: #ff4444; }
    .btn.big { padding: 1rem 2rem; font-size: 1.2rem; background: #ff0; color: black; }
    .board { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; max-width: 90vw; width: 100%; aspect-ratio: 1; margin: 1rem auto; }
    .tile { background: #16213e; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: clamp(0.7rem, 2.3vw, 1.1rem); font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(0,0,0,0.3); position: relative; overflow: hidden; min-height: 0; }
    .tile.selected { transform: scale(0.95); box-shadow: 0 0 20px #00ff88; z-index: 10; }
    .tile.match { animation: pop 0.4s ease forwards; background: #00ff88 !important; color: black; }
    .tile.wrong { animation: shake 0.4s ease; background: #ff4444 !important; }
    .tile.drop { animation: dropAnim 0.5s ease; }
    @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(0); opacity: 0; } }
    @keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
    @keyframes dropAnim { 0% { transform: translateY(-100%); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    .score { font-size: 1.5rem; font-weight: bold; color: #00ff88; margin: 0.5rem 0; }
    .timer { font-size: 1.8rem; font-weight: bold; color: #fff; }
    .timer.warning { color: #ff0; animation: pulse 1s infinite; }
    .timer.danger { color: #ff4444; animation: pulse 0.5s infinite; }
    .combo { color: #ff0; font-size: 1.2rem; margin: 0.5rem 0; }
    .back-btn { position: absolute; top: 10px; left: 10px; z-index: 100; }
    .loading { text-align: center; color: #00ff88; font-size: 1.2rem; }
    .stats { margin: 1rem 0; font-size: 1.1rem; }
    .stats span { display: block; margin: 0.5rem 0; }
    h1 { font-size: 2.2rem; margin-bottom: 1rem; color: #00ff88; }
    h2 { margin-bottom: 1rem; }
  </style>
</head>
<body>
  <div id="app" class="container"></div>

  <script>
    // 內嵌音效
    const sounds = {
      match: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      wrong: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      drop: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      combo: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      countdown: new Audio('data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAA')
    };
    Object.values(sounds).forEach(s => s.volume = 0.5);

    // 全域變數
    let currentLevel = null, currentUnitStart = null, selectedTime = 180; // 預設 3 分鐘
    let board = [], selected = [], score = 0, combo = 0, correctCount = 0, wrongCount = 0;
    let timeLeft = selectedTime;
    let timerId = null;
    let gameActive = false;
    const GRID_SIZE = 6;
    const TIME_OPTIONS = { 180: '3分鐘', 300: '5分鐘', 600: '10分鐘' };
    const CSV_URLS = Array.from({length: 6}, (_, i) => `https://raw.githubusercontent.com/DuCJ-creator/iVocab-Self-Practice/main/level${i+1}.csv`);

    const app = document.getElementById('app');

    // 載入 CSV
    async function loadCSV(level) {
      const response = await fetch(CSV_URLS[level - 1]);
      const text = await response.text();
      return text.split('\n').slice(1).map(line => {
        const cols = line.split(',').map(s => s.trim().replace(/^"|"$/g, ''));
        if (cols.length < 6) return null;
        const [lvl, unit, no, word, pos, meaning] = cols;
        return { level: parseInt(lvl), unit: parseInt(unit), no, word, pos, meaning };
      }).filter(row => row && row.word && row.meaning);
    }

    // 產生配對池
    function generatePool(words) {
      const shuffled = words.sort(() => Math.random() - 0.5).slice(0, 18);
      const wordTiles = shuffled.map(w => ({ text: w.word, type: 'word', pair: w.meaning }));
      const meaningTiles = shuffled.map(w => ({ text: w.meaning, type: 'meaning', pair: w.word }));
      return [...wordTiles, ...meaningTiles].sort(() => Math.random() - 0.5);
    }

    // 建立棋盤
    function createBoard(pool) {
      const grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
      let idx = 0;
      for (let r = 0; r < GRID_SIZE && idx < pool.length; r++) {
        for (let c = 0; c < GRID_SIZE && idx < pool.length; c++) {
          grid[r][c] = { ...pool[idx++], row: r, col: c };
        }
      }
      return grid;
    }

    // 開始計時
    function startTimer() {
      gameActive = true;
      timeLeft = selectedTime;
      timerId = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          endGame();
        } else if (timeLeft <= 10) {
          sounds.countdown.play();
        }
      }, 1000);
    }

    // 更新計時器
    function updateTimerDisplay() {
      const timerEl = app.querySelector('.timer');
      if (!timerEl) return;
      const mins = Math.floor(timeLeft / 60).toString().padStart(2, '0');
      const secs = (timeLeft % 60).toString().padStart(2, '0');
      timerEl.textContent = `時間: ${mins}:${secs}`;
      timerEl.className = 'timer';
      if (timeLeft <= 10) timerEl.classList.add('danger');
      else if (timeLeft <= 30) timerEl.classList.add('warning');
    }

    // 檢查是否全部消除
    function checkAllCleared() {
      return board.flat().every(tile => tile === null);
    }

    // 結束遊戲
    function endGame() {
      if (!gameActive) return;
      gameActive = false;
      clearInterval(timerId);
      const accuracy = correctCount + wrongCount > 0 ? Math.round((correctCount / (correctCount + wrongCount)) * 100) : 0;
      const finalCombo = combo > 0 ? Math.floor(combo / 3) + 1 : 0;

      app.innerHTML = `
        <div class="game-over">
          <h1>Game Over!</h1>
          <div class="stats">
            <span class="score">最終得分: ${score}</span>
  <span>正確: ${correctCount} 次</span>
            <span>錯誤: ${wrongCount} 次</span>
            <span>正確率: ${accuracy}%</span>
            <span>最高連擊: x${finalCombo}</span>
            <span>剩餘時間: ${Math.floor(timeLeft / 60)}分${timeLeft % 60}秒</span>
          </div>
          <button class="btn big" onclick="resetGame()">重新開始</button>
          <button class="btn" style="margin-top:0.5rem;" onclick="renderLevelSelector()">返回選單</button>
        </div>
      `;
    }

    // 提前結束
    function quitGame() {
      if (confirm('確定要提前結束遊戲嗎？')) {
        endGame();
      }
    }

    // 移除並掉落
    function removeAndDrop(tilesToRemove) {
      const newBoard = board.map(row => [...row]);
      tilesToRemove.forEach(t => { newBoard[t.row][t.col] = null; });

      for (let c = 0; c < GRID_SIZE; c++) {
        const colTiles = [];
        for (let r = 0; r < GRID_SIZE; r++) {
          if (newBoard[r][c]) colTiles.push(newBoard[r][c]);
        }
        const empty = GRID_SIZE - colTiles.length;
        for (let r = 0; r < empty; r++) newBoard[r][c] = null;
        colTiles.forEach((tile, i) => {
          newBoard[empty + i][c] = { ...tile, row: empty + i };
        });
      }

      sounds.drop.play();
      setTimeout(() => {
        board = newBoard;
        renderBoard();
        if (checkAllCleared()) endGame();
      }, 100);
    }

    // 檢查配對
    function checkMatch() {
      if (selected.length !== 2) return;
      const [a, b] = selected;
      const correct = (a.type === 'word' && a.pair === b.text) || (b.type === 'word' && b.pair === a.text);

      if (correct) {
        correctCount++;
        sounds.match.play();
        if (combo > 0 && combo % 3 === 0) sounds.combo.play();
        const points = 10 * (Math.floor(combo / 3) + 1);
        score += points;
        combo++;
        removeAndDrop(selected);
      } else {
        wrongCount++;
        sounds.wrong.play();
        const penalty = 10 * (Math.floor(Math.abs(combo) / 3) + 1);
        score -= penalty;
        combo = 0;
        selected.forEach(s => {
          const el = document.querySelector(`[data-pos="${s.row}-${s.col}"]`);
          if (el) el.classList.add('wrong');
        });
        setTimeout(() => {
          selected.forEach(s => {
            const el = document.querySelector(`[data-pos="${s.row}-${s.col}"]`);
            if (el) el.classList.remove('wrong');
          });
          selected = [];
          renderBoard();
        }, 600);
      }

      // 檢查 0 分
      if (score <= 0) {
        score = 0;
        setTimeout(endGame, 800);
      }

      renderScore();
      selected = [];
    }

    // 點擊處理
    function handleTileClick(row, col, tile) {
      if (!gameActive || selected.length === 2 || !tile) return;
      selected.push({ row, col, ...tile });
      renderBoard();
      if (selected.length === 2) setTimeout(checkMatch, 300);
    }

    // 渲染棋盤
    function renderBoard() {
      const boardEl = document.createElement('div');
      boardEl.className = 'board';
      board.flat().forEach((tile, i) => {
        const tileEl = document.createElement('div');
        if (!tile) {
          tileEl.className = 'tile';
          tileEl.style.visibility = 'hidden';
        } else {
          tileEl.className = 'tile';
          tileEl.textContent = tile.text;
          tileEl.dataset.pos = `${tile.row}-${tile.col}`;
          if (selected.some(s => s.row === tile.row && s.col === tile.col)) tileEl.classList.add('selected');
          tileEl.addEventListener('click', () => handleTileClick(tile.row, tile.col, tile));
          tileEl.addEventListener('touchstart', e => { e.preventDefault(); handleTileClick(tile.row, tile.col, tile); });
        }
        boardEl.appendChild(tileEl);
      });

      app.innerHTML = `
        <button class="btn back-btn" onclick="renderLevelSelector()">返回</button>
        <div class="timer">時間: --:--</div>
        <div class="score">Score: ${score}</div>
        ${combo > 0 ? `<div class="combo">Combo x${Math.floor(combo / 3) + 1}</div>` : ''}
        ${boardEl.outerHTML}
        <div style="display:flex; gap:0.5rem; justify-content:center; margin-top:0.5rem;">
          <button class="btn" onclick="resetGame()">重置</button>
          <button class="btn danger" onclick="quitGame()">結束遊戲</button>
        </div>
      `;
      updateTimerDisplay();
    }

    // 渲染分數
    function renderScore() {
      const scoreEl = app.querySelector('.score');
      if (scoreEl) scoreEl.textContent = `Score: ${score}`;
      const comboEl = app.querySelector('.combo');
      if (comboEl) comboEl.textContent = combo > 0 ? `Combo x${Math.floor(combo / 3) + 1}` : '';
    }

    // 初始化遊戲
    async function initGame(level, unitStart) {
      app.innerHTML = '<div class="loading">載入單字...</div>';
      const data = await loadCSV(level);
      const units = data.filter(d => d.unit >= unitStart && d.unit <= unitStart + 4);
      if (units.length < 18) {
        alert('此範圍單字不足！請選擇其他範圍。');
        renderUnitSelector();
        return;
      }
      const pool = generatePool(units);
      board = createBoard(pool);
      selected = []; score = 0; combo = 0; correctCount = 0; wrongCount = 0;
      renderBoard();
      startTimer();
    }

    // 重置遊戲
    function resetGame() {
      if (timerId) clearInterval(timerId);
      initGame(currentLevel, currentUnitStart);
    }

    // Level 選擇
    function renderLevelSelector() {
      if (timerId) clearInterval(timerId);
      gameActive = false;
      app.innerHTML = `
        <div class="selector">
          <h2>選擇 Level</h2>
          <div class="unit-group">
            ${[1,2,3,4,5,6].map(l => `<button class="btn" onclick="selectLevel(${l})">Level ${l}</button>`).join('')}
          </div>
        </div>
      `;
    }

    function selectLevel(level) {
      currentLevel = level;
      renderTimeSelector();
    }

    // 時間選擇
    function renderTimeSelector() {
      app.innerHTML = `
        <button class="btn back-btn" onclick="renderLevelSelector()">返回</button>
        <div class="selector">
          <h2>選擇遊戲時間</h2>
          <div class="time-group">
            ${Object.entries(TIME_OPTIONS).map(([sec, label]) => 
              `<button class="btn ${selectedTime == sec ? 'active' : ''}" onclick="selectTime(${sec})">${label}</button>`
            ).join('')}
          </div>
        </div>
      `;
    }

    function selectTime(seconds) {
      selectedTime = seconds;
      renderUnitSelector();
    }

    // Unit 選擇
    function renderUnitSelector() {
      const groups = [];
      for (let i = 1; i <= 50; i += 5) {
        groups.push({ start: i, end: Math.min(i + 4, 50) });
      }
      app.innerHTML = `
        <button class="btn back-btn" onclick="renderTimeSelector()">返回</button>
        <div class="selector">
          <h2>Level ${currentLevel} - 選擇 Unit 範圍</h2>
          <div class="unit-group">
            ${groups.map(g => `<button class="btn" onclick="selectUnitRange(${g.start})">${g.start}–${g.end}</button>`).join('')}
          </div>
        </div>
      `;
    }

    function selectUnitRange(start) {
      currentUnitStart = start;
      initGame(currentLevel, start);
    }

    // 啟動
    renderLevelSelector();
  </script>
</body>
</html>
