<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vocab Crush</title>
  <!-- PapaParse CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }

    /* ğŸŒˆ æ˜äº®éŠæˆ²é¢¨ä¸»é¡Œ */
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #fdfbfb 0%, #ebedff 50%, #d1f7ff 100%);
      color:#333;
      user-select:none;
      height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding:1rem;
      overflow:hidden;
    }
    .container {
      max-width:900px;
      width:100%;
      text-align:center;
    }
    .selector, .game-over {
      background:#ffffffcc;
      padding:1.5rem;
      border-radius:16px;
      margin:1rem auto;
      max-width:900px;
      box-shadow:0 8px 20px rgba(0,0,0,0.08);
    }
    .unit-group, .time-group {
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
      gap:0.5rem;
      margin-top:1rem;
    }

    .btn {
      padding:0.8rem 1rem;
      background:#4c6fff;
      color:white;
      border:none;
      border-radius:999px;
      font-size:1rem;
      cursor:pointer;
      transition:0.2s;
      touch-action:manipulation;
      box-shadow:0 4px 10px rgba(76,111,255,0.25);
    }
    .btn:hover { background:#3353e6; }
    .btn:active { transform:scale(0.96); }
    .btn.active { background:#ffb800; color:#333; }
    .btn.danger { background:#ff5c5c; }
    .btn.big { padding:1rem 2rem; font-size:1.2rem; background:#ffb800; color:#333; }

    .board {
      display:grid;
      grid-template-columns:repeat(6,1fr);
      gap:8px;
      max-width:900px;
      width:100%;
      aspect-ratio:1;
      margin:1rem auto;
    }
    .tile {
      background:#ffffff;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:clamp(0.7rem,2.3vw,1.1rem);
      font-weight:bold;
      cursor:pointer;
      transition:all 0.2s ease;
      box-shadow:0 3px 8px rgba(0,0,0,0.08);
      border:2px solid #d7e2ff;
      position:relative;
      overflow:hidden;
      min-height:0;
      color:#333;
    }
    .tile.selected {
      transform:scale(0.96);
      box-shadow:0 0 15px rgba(255,184,0,0.7);
      border-color:#ffb800;
      background:#fff5cf;
      z-index:10;
    }
    .tile.match { animation:pop 0.4s ease forwards; background:#a9ffcb !important; color:#103; }
    .tile.wrong { animation:shake 0.4s ease; background:#ffd1d1 !important; }
    .tile.drop { animation:dropAnim 0.5s ease; }

    @keyframes pop {
      0%{transform:scale(1)}
      50%{transform:scale(1.2)}
      100%{transform:scale(0);opacity:0}
    }
    @keyframes shake {
      0%,100%{transform:translateX(0)}
      25%{transform:translateX(-6px)}
      75%{transform:translateX(6px)}
    }
    @keyframes dropAnim {
      0%{transform:translateY(-100%);opacity:0}
      100%{transform:translateY(0);opacity:1}
    }
    @keyframes pulse {
      0%,100%{opacity:1}
      50%{opacity:0.5}
    }

    /* ä¸Šæ–¹ HUDï¼šè¨ˆæ™‚ + è¨ˆåˆ† */
    .hud {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:1rem;
      margin-top:0.5rem;
      padding:0.6rem 0.9rem;
      background:#ffffffdd;
      border-radius:14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
    }
    .timer {
      font-size:1.6rem;
      font-weight:bold;
      color:#333;
    }
    .timer.warning { color:#ff9500; animation:pulse 1s infinite; }
    .timer.danger { color:#ff3b30; animation:pulse 0.5s infinite; }

    .score-box {
      text-align:right;
    }
    .score-main {
      font-size:1.6rem;
      font-weight:bold;
      color:#4c6fff;
    }
    .score-label {
      font-size:0.9rem;
      display:block;
      color:#888;
    }
    .score-delta-label {
      font-size:1rem;
      min-height:1.1rem;
      margin-top:2px;
    }

    .combo {
      color:#ff9500;
      font-size:1.1rem;
      margin:0.4rem 0;
      font-weight:bold;
      text-shadow:0 0 6px #fff;
    }

    .back-btn {
      position:absolute;
      top:10px;
      left:10px;
      z-index:100;
    }
    .loading {
      text-align:center;
      color:#4c6fff;
      font-size:1.2rem;
    }
    .stats { margin:1rem 0; font-size:1.1rem; }
    .stats span { display:block; margin:0.5rem 0; }

    h1 { font-size:2.2rem; margin-bottom:1rem; color:#4c6fff; text-shadow:0 2px 6px rgba(0,0,0,0.1); }
    h2 { margin-bottom:1rem; color:#333; }

    /* ğŸ’— / ğŸ· ä¸­å¤®å‹•ç•«æç¤º */
    .feedback {
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%) scale(0.5);
      font-size:3rem;
      opacity:0;
      pointer-events:none;
      z-index:200;
      transition:transform 0.25s ease, opacity 0.25s ease;
    }
    .feedback.show {
      opacity:1;
      transform:translate(-50%,-50%) scale(1.1);
    }
    .feedback.correct { text-shadow:0 0 20px rgba(255,105,180,0.9); }
    .feedback.wrong  { text-shadow:0 0 20px rgba(255,59,48,0.9); }
  </style>
</head>
<body>
  <div id="app" class="container"></div>

  <script>
    // éŸ³æ•ˆ
    const sounds = {
      match: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      wrong: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      drop: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      combo: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      countdown: new Audio('data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAA')
    };
    Object.values(sounds).forEach(s => s.volume = 0.5);

    // å…¨åŸŸè®Šæ•¸
    let currentLevel, currentUnitStart, selectedTime = 180;
    let board = [], selected = [], score = 0, combo = 0, correctCount = 0, wrongCount = 0;
    let timeLeft = selectedTime, timerId = null, gameActive = false;

    const GRID_SIZE = 6;
    const TIME_OPTIONS = { 180: '3åˆ†é˜', 300: '5åˆ†é˜', 600: '10åˆ†é˜' };
    const CSV_URLS = Array.from({length:6}, (_,i) =>
      `https://raw.githubusercontent.com/DuCJ-creator/iVocab-Self-Practice/main/level${i+1}.csv`
    );

    const app = document.getElementById('app');

    // â”€â”€â”€ CSV è¼‰å…¥ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function loadCSV(level) {
      return new Promise((resolve) => {
        Papa.parse(CSV_URLS[level-1], {
          download: true,
          header: true,
          complete: (results) => {
            const data = results.data
              .filter(r => r.Level && r.Unit && r.Word && r['Chinese Meaning'])
              .map(r => ({
                level: parseInt(r.Level),
                unit: parseInt(r.Unit),
                word: r.Word.trim(),
                meaning: r['Chinese Meaning'].replace(/;/g, 'ï¼›').trim()
              }));
            resolve(data);
          },
          error: () => { alert('è¼‰å…¥å¤±æ•—'); resolve([]); }
        });
      });
    }

    // ç”Ÿæˆ 18 å°
    function generatePool(words) {
      const picked = [];
      while (picked.length < 18) {
        const rand = words[Math.floor(Math.random() * words.length)];
        if (rand.word && rand.meaning) picked.push(rand);
      }
      const wordTiles    = picked.map(w => ({ text: w.word,    type: 'word',    pair: w.meaning }));
      const meaningTiles = picked.map(w => ({ text: w.meaning, type: 'meaning', pair: w.word    }));
      return [...wordTiles, ...meaningTiles].sort(() => Math.random() - 0.5);
    }

    // å»ºç«‹æ£‹ç›¤
    function createBoard(pool) {
      const grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      let idx = 0;
      for (let r = 0; r < GRID_SIZE && idx < pool.length; r++) {
        for (let c = 0; c < GRID_SIZE && idx < pool.length; c++) {
          grid[r][c] = { ...pool[idx++], row: r, col: c };
        }
      }
      return grid;
    }

    // æ‰è½é‚è¼¯
    function dropTiles() {
      const newBoard = board.map(row => [...row]);
      for (let c = 0; c < GRID_SIZE; c++) {
        let writePos = GRID_SIZE - 1;
        for (let r = GRID_SIZE - 1; r >= 0; r--) {
          if (newBoard[r][c]) {
            if (r !== writePos) {
              newBoard[writePos][c] = { ...newBoard[r][c], row: writePos };
              newBoard[r][c] = null;
            }
            writePos--;
          }
        }
      }
      return newBoard;
    }

    // â”€â”€â”€ UIï¼šä¸­å¤® ğŸ’— / ğŸ· æç¤º â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function showFeedback(type) {
      const fb = document.getElementById('feedback');
      if (!fb) return;
      if (type === 'correct') {
        fb.textContent = 'ğŸ’—ğŸ’—';
        fb.className = 'feedback show correct';
      } else {
        fb.textContent = 'ğŸ·ğŸ·';
        fb.className = 'feedback show wrong';
      }
      setTimeout(() => {
        const fb2 = document.getElementById('feedback');
        if (fb2) fb2.className = 'feedback';
      }, 450);
    }

    // â”€â”€â”€ UIï¼šæ›´æ–°åˆ†æ•¸ HUDï¼ˆç©©å®šç‰ˆï¼Œç›´æ¥æ“ä½œ DOMï¼‰ â”€â”€â”€â”€â”€
    function updateScoreHUD(delta = null) {
      const scoreEl = document.getElementById('scoreVal');
      const deltaEl = document.getElementById('scoreDelta');
      if (scoreEl) scoreEl.textContent = score;

      if (!deltaEl) return;

      if (delta === null) {
        // ä¸è®Šæ›´æ–‡å­—ï¼Œåªä¿ç•™åŸæœ¬å…§å®¹
        return;
      }

      if (delta === 0) {
        deltaEl.textContent = '';
        deltaEl.style.color = '#888';
      } else {
        deltaEl.textContent = delta > 0 ? `æœ¬æ¬¡ +${delta} åˆ†` : `æœ¬æ¬¡ ${delta} åˆ†`;
        deltaEl.style.color = delta > 0 ? '#1da93a' : '#ff3b30';
      }
    }

    // â”€â”€â”€ é»æ“Šä¸€æ ¼ï¼ˆæ”¯æ´å†é»ä¸€æ¬¡å–æ¶ˆé¸å–ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function handleTileClick(r, c) {
      if (!gameActive) return;
      const t = board[r][c];
      if (!t) return;

      // å·²é¸çš„å†é»ä¸€æ¬¡ -> å–æ¶ˆé¸å–
      const idx = selected.findIndex(s => s.row === r && s.col === c);
      if (idx !== -1) {
        selected.splice(idx, 1);
        renderBoard();
        return;
      }

      if (selected.length >= 2) return;

      selected.push({ row: r, col: c, ...t });
      renderBoard();
      if (selected.length === 2) {
        setTimeout(checkMatch, 250);
      }
    }

    // â”€â”€â”€ æ¸²æŸ“æ£‹ç›¤ + HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderBoard() {
      let html = `
        <button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="hud">
          <div class="timer">æ™‚é–“ï¼š--:--</div>
          <div class="score-box">
            <span class="score-label">ç›®å‰å¾—åˆ†</span>
            <div class="score-main"><span id="scoreVal">${score}</span></div>
            <div class="score-delta-label" id="scoreDelta"></div>
          </div>
        </div>
        ${combo > 0 ? `<div class="combo">Combo x${Math.floor(combo/3)+1}</div>` : ''}
        <div class="board" id="gameBoard">`;

      board.forEach((row, r) => {
        row.forEach((tile, c) => {
          if (!tile) {
            html += `<div class="tile" style="visibility:hidden"></div>`;
          } else {
            const isSel = selected.some(s => s.row === r && s.col === c);
            html += `<div class="tile ${isSel ? 'selected' : ''}" onclick="handleTileClick(${r},${c})">${tile.text}</div>`;
          }
        });
      });

      html += `</div>
        <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:0.5rem;">
          <button class="btn" onclick="resetGame()">é‡ç½®</button>
          <button class="btn danger" onclick="quitGame()">çµæŸ</button>
        </div>
        <div id="feedback" class="feedback"></div>`;

      app.innerHTML = html;
      updateTimerDisplay();
      // åˆæ¬¡æ¸²æŸ“æ™‚ï¼ŒæŠŠåˆ†æ•¸ç‹€æ…‹åŒæ­¥åˆ° HUD
      updateScoreHUD(0);
    }

    // â”€â”€â”€ æª¢æŸ¥é…å° + è¨ˆåˆ† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function checkMatch() {
      if (selected.length < 2) return;
      const [a, b] = selected;
      let delta = 0;

      const correct =
        (a.type === 'word' && a.pair === b.text) ||
        (b.type === 'word' && b.pair === a.text);

      if (correct) {
        correctCount++;
        sounds.match.play();
        showFeedback('correct');

        const baseCombo = Math.floor(combo / 3) + 1;
        delta = 10 * baseCombo;
        score += delta;
        if (combo % 3 === 0) sounds.combo.play();
        combo++;

        // æ­£ç¢º -> ç§»é™¤
        board[a.row][a.col] = null;
        board[b.row][b.col] = null;
        selected = [];

        setTimeout(() => {
          sounds.drop.play();
          board = dropTiles();
          renderBoard();
          updateScoreHUD(delta);  // âœ… é¡¯ç¤ºã€Œæœ¬æ¬¡ +X åˆ†ã€
          if (board.flat().every(t => !t)) endGame('å…¨æ¶ˆï¼');
        }, 250);
      } else {
        wrongCount++;
        sounds.wrong.play();
        showFeedback('wrong');

        const baseCombo = Math.floor(Math.abs(combo) / 3) + 1;
        delta = -10 * baseCombo;
        score = Math.max(0, score + delta);
        combo = 0;

        // éŒ¯çš„ -> ä¸æ¶ˆé™¤ï¼Œåªè§£é™¤é¸å–
        setTimeout(() => {
          selected = [];
          renderBoard();
          updateScoreHUD(delta);  // âœ… é¡¯ç¤ºã€Œæœ¬æ¬¡ -X åˆ†ã€
        }, 400);
      }

      if (score <= 0) {
        setTimeout(() => endGame('åˆ†æ•¸æ­¸é›¶'), 700);
      }
    }

    // â”€â”€â”€ è¨ˆæ™‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startTimer() {
      gameActive = true;
      timeLeft = Number(selectedTime);
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          endGame();
        } else if (timeLeft <= 10) {
          sounds.countdown.play();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const el = app.querySelector('.timer');
      if (!el) return;
      const m = String(Math.floor(timeLeft/60)).padStart(2,'0');
      const s = String(timeLeft%60).padStart(2,'0');
      el.textContent = `æ™‚é–“ï¼š${m}:${s}`;
      el.className = 'timer';
      if (timeLeft <= 10) el.classList.add('danger');
      else if (timeLeft <= 30) el.classList.add('warning');
    }

    // â”€â”€â”€ çµæŸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function endGame(reason = 'æ™‚é–“åˆ°') {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      const acc = correctCount + wrongCount > 0
        ? Math.round(correctCount/(correctCount+wrongCount)*100)
        : 0;
      const maxCombo = combo > 0 ? Math.floor(combo/3)+1 : 1;

      app.innerHTML = `
        <div class="game-over">
          <h1>Game Over! (${reason})</h1>
          <div class="stats">
            <span class="score-main">æœ€çµ‚å¾—åˆ†ï¼š${score}</span>
            <span>æ­£ç¢ºï¼š${correctCount} æ¬¡</span>
            <span>éŒ¯èª¤ï¼š${wrongCount} æ¬¡</span>
            <span>æ­£ç¢ºç‡ï¼š${acc}%</span>
            <span>æœ€é«˜é€£æ“Šï¼šx${maxCombo}</span>
          </div>
          <button class="btn big" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
          <button class="btn" onclick="renderLevelSelector()">å›åˆ°é¸å–®</button>
        </div>`;
    }

    function quitGame() {
      if (confirm('æå‰çµæŸï¼Ÿ')) endGame('æ‰‹å‹•çµæŸ');
    }

    function resetGame() {
      if (!currentLevel || !currentUnitStart) {
        renderLevelSelector();
        return;
      }
      if (timerId) clearInterval(timerId);
      initGame(currentLevel, currentUnitStart);
    }

    // â”€â”€â”€ åˆå§‹åŒ–éŠæˆ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function initGame(level, unitStart) {
      app.innerHTML = '<div class="loading">å–®å­—è¼‰å…¥ä¸­...</div>';
      const data = await loadCSV(level);
      const units = data.filter(d => d.unit >= unitStart && d.unit <= unitStart + 4);
      if (units.length < 18) {
        alert('å–®å­—ä¸è¶³ï¼è«‹é¸åˆ¥çµ„ unit');
        renderUnitSelector();
        return;
      }
      const pool = generatePool(units);
      board = createBoard(pool);
      selected = [];
      score = 0;
      combo = 0;
      correctCount = 0;
      wrongCount = 0;
      renderBoard();
      updateScoreHUD(0); // âœ… åˆå§‹å¾—åˆ†é¡¯ç¤º 0
      startTimer();
    }

    // â”€â”€â”€ é¸å–® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderLevelSelector() {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      app.innerHTML = `
        <div class="selector">
          <h2>é¸æ“‡ Level</h2>
          <div class="unit-group">
            ${[1,2,3,4,5,6].map(l =>
              `<button class="btn" onclick="currentLevel=${l};renderTimeSelector()">Level ${l}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    function renderTimeSelector() {
      app.innerHTML = `
        <button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="selector">
          <h2>é¸æ“‡æ™‚é–“</h2>
          <div class="time-group">
            ${Object.entries(TIME_OPTIONS).map(([s,label]) =>
              `<button class="btn ${selectedTime==s?'active':''}" onclick="selectedTime=${s};renderUnitSelector()">${label}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    function renderUnitSelector() {
      const groups = [];
      for (let i=1; i<=50; i+=5) groups.push({start:i, end:Math.min(i+4,50)});

      app.innerHTML = `
        <button class="btn back-btn" onclick="renderTimeSelector()">è¿”å›</button>
        <div class="selector">
          <h2>Level ${currentLevel} - é¸æ“‡ Unit ç¯„åœ</h2>
          <div class="unit-group">
            ${groups.map(g =>
              `<button class="btn" onclick="currentUnitStart=${g.start};initGame(currentLevel,${g.start})">${g.start} â€“ ${g.end}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    // å•Ÿå‹•
    renderLevelSelector();
  </script>
</body>
</html>
