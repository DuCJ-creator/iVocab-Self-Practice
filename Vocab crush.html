<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Shirley's Vocab Crush</title>
  <!-- PapaParse CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }

    /* ğŸŒˆ èƒŒæ™¯ï¼‹æš—ç´‹ï¼‹æ•´é«”æ’ç‰ˆ */
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #fdfbfb 0%, #ebedff 50%, #d1f7ff 100%);
      color:#333;
      user-select:none;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:1rem;
      overflow-y:auto;
      overflow-x:hidden;
      position:relative;
    }

    /* æŸ”å’Œæš—ç´‹èƒŒæ™¯ */
    body::before {
      content:"";
      position:fixed;
      inset:0;
      background-image:
        radial-gradient(circle at 0 0, rgba(148,163,255,0.18) 0, transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(45,212,191,0.18) 0, transparent 55%),
        radial-gradient(circle at 50% 0, rgba(255,255,255,0.7) 0, transparent 60%);
      opacity:0.55;
      pointer-events:none;
      z-index:-1;
    }

    .container {
      max-width:900px;
      width:100%;
      text-align:center;
    }

    /* é é¦–æ¨™é¡Œå€ */
    .page-header {
      position:relative;
      text-align:center;
      margin-bottom:0.6rem;
      padding-top:0.2rem;
    }

    .title-glow {
      position:absolute;
      inset:0;
      margin:auto;
      width:260px;
      height:80px;
      background:radial-gradient(circle, rgba(255,255,255,0.95), rgba(148,163,255,0.16));
      filter:blur(12px);
      z-index:-1;
    }

    .game-title {
      font-size:clamp(2rem, 4vw, 2.7rem);
      letter-spacing:0.08em;
      font-weight:800;
      margin-bottom:0.15rem;
      background:linear-gradient(120deg, #4c6fff, #ff8bb0, #28c7b7);
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      text-shadow:0 3px 10px rgba(0,0,0,0.18);
      animation:floatTitle 4s ease-in-out infinite;
    }

    .game-subtitle {
      font-size:0.9rem;
      color:#666;
    }

    @keyframes floatTitle {
      0%,100% { transform:translateY(0); }
      50%     { transform:translateY(-4px); }
    }

    .selector, .game-over {
      background:#ffffffcc;
      padding:1.5rem;
      border-radius:16px;
      margin:1rem auto;
      max-width:900px;
      box-shadow:0 8px 20px rgba(0,0,0,0.08);
    }

    .unit-group, .time-group {
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
      gap:0.5rem;
      margin-top:1rem;
    }

    .btn {
      padding:0.8rem 1rem;
      background:#4c6fff;
      color:white;
      border:none;
      border-radius:999px;
      font-size:1rem;
      cursor:pointer;
      transition:0.2s;
      touch-action:manipulation;
      box-shadow:0 4px 10px rgba(76,111,255,0.25);
    }
    .btn:hover { background:#3353e6; }
    .btn:active { transform:scale(0.96); }
    .btn.active { background:#ffb800; color:#333; }
    .btn.danger { background:#ff5c5c; }
    .btn.big { padding:1rem 2rem; font-size:1.2rem; background:#ffb800; color:#333; }

    /* 4Ã—4 æ£‹ç›¤ */
    .board {
      display:grid;
      grid-template-columns:repeat(4, minmax(0, 1fr));
      gap:8px;
      max-width:900px;
      width:100%;
      margin:1rem auto;
    }

    .tile {
      background:#ffffff;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:clamp(0.7rem,2.8vw,1.1rem);
      font-weight:bold;
      cursor:pointer;
      transition:all 0.2s ease;
      box-shadow:0 3px 8px rgba(0,0,0,0.08);
      border:2px solid #d7e2ff;
      position:relative;
      overflow:hidden;
      min-height:0;
      color:#333;
      aspect-ratio: 1 / 1;
      text-align:center;
      padding:0.2rem;
    }
    .tile.selected {
      transform:scale(0.96);
      box-shadow:0 0 15px rgba(255,184,0,0.7);
      border-color:#ffb800;
      background:#fff5cf;
      z-index:10;
    }
    .tile.match { animation:pop 0.4s ease forwards; background:#a9ffcb !important; color:#103; }
    .tile.wrong { animation:shake 0.4s ease; background:#ffd1d1 !important; }
    .tile.drop { animation:dropAnim 0.5s ease; }

    @keyframes pop {
      0%{transform:scale(1)}
      50%{transform:scale(1.2)}
      100%{transform:scale(0);opacity:0}
    }
    @keyframes shake {
      0%,100%{transform:translateX(0)}
      25%{transform:translateX(-6px)}
      75%{transform:translateX(6px)}
    }
    @keyframes dropAnim {
      0%{transform:translateY(-100%);opacity:0}
      100%{transform:translateY(0);opacity:1}
    }
    @keyframes pulse {
      0%,100%{opacity:1}
      50%{opacity:0.5}
    }

    .hud {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:1rem;
      margin-top:0.5rem;
      padding:0.6rem 0.9rem;
      background:#ffffffdd;
      border-radius:14px;
      box-shadow:0 4px 12px rgba(0,0,0,0.06);
    }
    .timer {
      font-size:1.6rem;
      font-weight:bold;
      color:#333;
    }
    .timer.warning { color:#ff9500; animation:pulse 1s infinite; }
    .timer.danger { color:#ff3b30; animation:pulse 0.5s infinite; }

    .score-box {
      text-align:right;
    }
    .score-main {
      font-size:1.6rem;
      font-weight:bold;
      color:#4c6fff;
    }
    .score-label {
      font-size:0.9rem;
      display:block;
      color:#888;
    }

    .score-big {
      margin-top:0.2rem;
      font-size:1.3rem;
      font-weight:bold;
      color:#4c6fff;
    }

    .back-btn {
      position:absolute;
      top:10px;
      left:10px;
      z-index:100;
    }
    .loading {
      text-align:center;
      color:#4c6fff;
      font-size:1.2rem;
    }
    .stats { margin:1rem 0; font-size:1.1rem; }
    .stats span { display:block; margin:0.5rem 0; }

    h1 { font-size:2.2rem; margin-bottom:1rem; color:#4c6fff; text-shadow:0 2px 6px rgba(0,0,0,0.1); }
    h2 { margin-bottom:1rem; color:#333; }

    .feedback {
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%) scale(0.5);
      font-size:3rem;
      opacity:0;
      pointer-events:none;
      z-index:200;
      transition:transform 0.25s ease, opacity 0.25s ease;
    }
    .feedback.show {
      opacity:1;
      transform:translate(-50%,-50%) scale(1.1);
    }
    .feedback.correct { text-shadow:0 0 20px rgba(255,105,180,0.9); }
    .feedback.wrong  { text-shadow:0 0 20px rgba(255,59,48,0.9); }

    .score-pop {
      position:fixed;
      top:35%;
      left:50%;
      transform:translate(-50%,-50%) scale(0.5);
      font-size:2.2rem;
      font-weight:bold;
      opacity:0;
      pointer-events:none;
      z-index:210;
    }
    .score-pop.show.gain {
      color:#1da93a;
      text-shadow:0 0 12px rgba(29,169,58,0.8);
      animation:scorePop 0.7s ease-out;
    }
    .score-pop.show.loss {
      color:#ff3b30;
      text-shadow:0 0 12px rgba(255,59,48,0.8);
      animation:scorePop 0.7s ease-out;
    }
    @keyframes scorePop {
      0%   { opacity:0; transform:translate(-50%,-50%) scale(0.5); }
      30%  { opacity:1; transform:translate(-50%,-50%) scale(1.0); }
      100% { opacity:0; transform:translate(-50%,-80%) scale(1.1); }
    }
  </style>
</head>
<body>
  <!-- â­ å…¨åŸŸæ¨™é¡Œå€ -->
  <div class="page-header">
    <div class="title-glow"></div>
    <div class="game-title">Shirley's Vocab Crush</div>
    <p class="game-subtitle">Match words and meanings, keep your streak, and donâ€™tè®“åˆ†æ•¸æ­¸é›¶ï¼</p>
  </div>

  <div id="app" class="container"></div>

  <script>
    const sounds = {
      match: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      wrong: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      drop: new Audio('data:audio/wav;base64,UklGRl4GAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhAA'),
      countdown: new Audio('data:audio/wav;base64,UklGRiQCAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAA')
    };
    Object.values(sounds).forEach(s => s.volume = 0.5);

    let currentLevel, currentUnitStart, selectedTime = 180;
    let board = [], selected = [];
    let score = 0, correctCount = 0, wrongCount = 0;
    let correctStreak = 0, wrongStreak = 0, maxCorrectStreak = 0;
    let timeLeft = selectedTime, timerId = null, gameActive = false;

    const GRID_SIZE = 4;
    const TIME_OPTIONS = { 180: '3åˆ†é˜', 300: '5åˆ†é˜', 600: '10åˆ†é˜' };
    const CSV_URLS = Array.from({length:6}, (_,i) =>
      `https://raw.githubusercontent.com/DuCJ-creator/iVocab-Self-Practice/main/level${i+1}.csv`
    );

    let pairs = [];
    let tilePool = [];

    const app = document.getElementById('app');

    function shuffle(arr) {
      return arr.sort(() => Math.random() - 0.5);
    }

    async function loadCSV(level) {
      return new Promise((resolve) => {
        Papa.parse(CSV_URLS[level-1], {
          download: true,
          header: true,
          complete: (results) => {
            const data = results.data
              .filter(r => r.Level && r.Unit && r.Word && r['Chinese Meaning'])
              .map((r) => {
                const posRaw =
                  (r['Part of Speech'] || r['part of speech'] ||
                   r.POS || r.Pos || r['è©æ€§'] || '').trim();
                return {
                  level: parseInt(r.Level),
                  unit: parseInt(r.Unit),
                  word: r.Word.trim(),
                  meaning: r['Chinese Meaning'].replace(/;/g, 'ï¼›').trim(),
                  pos: posRaw
                };
              });
            resolve(data);
          },
          error: () => { alert('è¼‰å…¥å¤±æ•—'); resolve([]); }
        });
      });
    }

    function generatePairPool(words) {
      return words.map((w, idx) => {
        const displayWord = w.pos ? `${w.word} (${w.pos})` : w.word;
        return {
          id: idx,
          wordTile:   { text: displayWord, type: 'word',    pairId: idx },
          meaningTile:{ text: w.meaning,   type: 'meaning', pairId: idx }
        };
      });
    }

    function createBoard(tiles) {
      const grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
      const shuffledTiles = shuffle([...tiles]);
      let idx = 0;
      for (let r = 0; r < GRID_SIZE && idx < shuffledTiles.length; r++) {
        for (let c = 0; c < GRID_SIZE && idx < shuffledTiles.length; c++) {
          grid[r][c] = { ...shuffledTiles[idx++], row: r, col: c };
        }
      }
      return grid;
    }

    function dropTiles() {
      const newBoard = board.map(row => [...row]);
      for (let c = 0; c < GRID_SIZE; c++) {
        let writePos = GRID_SIZE - 1;
        for (let r = GRID_SIZE - 1; r >= 0; r--) {
          if (newBoard[r][c]) {
            if (r !== writePos) {
              newBoard[writePos][c] = { ...newBoard[r][c], row: writePos, col: c };
              newBoard[r][c] = null;
            }
            writePos--;
          }
        }
      }
      return newBoard;
    }

    function refillTiles(boardIn) {
      const newBoard = boardIn.map(row => [...row]);
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (!newBoard[r][c] && tilePool.length > 0) {
            const t = tilePool.pop();
            newBoard[r][c] = { ...t, row: r, col: c };
          }
        }
      }
      return newBoard;
    }

    function refreshBoard() {
      const currentTiles = board.flat().filter(Boolean);
      const allTiles = [...currentTiles, ...tilePool];

      const group = {};
      for (const t of allTiles) {
        if (t.pairId == null) continue;
        if (!group[t.pairId]) group[t.pairId] = { word:null, meaning:null };
        if (t.type === 'word') group[t.pairId].word = t;
        else if (t.type === 'meaning') group[t.pairId].meaning = t;
      }

      const fullPairs = [];
      for (const pid in group) {
        const g = group[pid];
        if (g.word && g.meaning) fullPairs.push(g);
      }

      if (fullPairs.length === 0) {
        endGame('æ²’æœ‰å¯é…å°çš„å–®å­—äº†');
        return;
      }

      const maxPairsOnBoard = Math.floor(GRID_SIZE * GRID_SIZE / 2);
      const neededPairs = Math.min(fullPairs.length, maxPairsOnBoard);
      const chosenPairs = shuffle(fullPairs).slice(0, neededPairs);

      const newTiles = [];
      chosenPairs.forEach(p => {
        newTiles.push({ ...p.word, row: undefined, col: undefined });
        newTiles.push({ ...p.meaning, row: undefined, col: undefined });
      });

      board = createBoard(newTiles);

      const chosenIds = new Set(chosenPairs.map(p => p.word.pairId));
      tilePool = shuffle(
        allTiles.filter(t => t.pairId != null && !chosenIds.has(t.pairId))
                .map(t => ({ ...t, row: undefined, col: undefined }))
      );

      selected = [];
      renderBoard();
    }

    function showFeedback(type) {
      const fb = document.getElementById('feedback');
      if (!fb) return;
      if (type === 'correct') {
        fb.textContent = 'ğŸ’—ğŸ’—';
        fb.className = 'feedback show correct';
      } else {
        fb.textContent = 'ğŸ·ğŸ·';
        fb.className = 'feedback show wrong';
      }
      setTimeout(() => {
        const fb2 = document.getElementById('feedback');
        if (fb2) fb2.className = 'feedback';
      }, 450);
    }

    function showScorePop(delta) {
      const pop = document.getElementById('scorePop');
      if (!pop || !delta) return;
      if (delta > 0) {
        pop.textContent = `+${delta} âœ¨`;
        pop.className = 'score-pop show gain';
      } else {
        pop.textContent = `${delta} ğŸ’¥`;
        pop.className = 'score-pop show loss';
      }
      setTimeout(() => {
        const p = document.getElementById('scorePop');
        if (p) p.className = 'score-pop';
      }, 700);
    }

    function updateScoreHUD(delta) {
      const scoreEl   = document.getElementById('scoreVal');
      const scoreBig  = document.getElementById('scoreBig');
      if (scoreEl)  scoreEl.textContent  = score;
      if (scoreBig) scoreBig.textContent = score;

      if (delta && delta !== 0) {
        showScorePop(delta);
      }
    }

    function handleTileClick(r, c) {
      if (!gameActive) return;
      const t = board[r][c];
      if (!t) return;

      const idx = selected.findIndex(s => s.row === r && s.col === c);
      if (idx !== -1) {
        selected.splice(idx, 1);
        renderBoard();
        return;
      }

      if (selected.length >= 2) return;

      selected.push({ row: r, col: c, ...t });
      renderBoard();
      if (selected.length === 2) {
        setTimeout(checkMatch, 250);
      }
    }

    function renderBoard() {
      let html = `
        <button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="hud">
          <div class="timer">æ™‚é–“ï¼š--:--</div>
          <div class="score-box">
            <span class="score-label">ç›®å‰å¾—åˆ†</span>
            <div class="score-main"><span id="scoreVal">${score}</span></div>
          </div>
        </div>
        <div class="board" id="gameBoard">`;

      board.forEach((row, r) => {
        row.forEach((tile, c) => {
          if (!tile) {
            html += `<div class="tile" style="visibility:hidden"></div>`;
          } else {
            const isSel = selected.some(s => s.row === r && s.col === c);
            html += `<div class="tile ${isSel ? 'selected' : ''}" onclick="handleTileClick(${r},${c})">${tile.text}</div>`;
          }
        });
      });

      html += `</div>
        <div class="score-big">ç¸½åˆ†ï¼š<span id="scoreBig">${score}</span></div>
        <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:0.5rem;flex-wrap:wrap;">
          <button class="btn" onclick="resetGame()">é‡ç©æœ¬çµ„</button>
          <button class="btn" onclick="refreshBoard()">é‡æŠ½</button>
          <button class="btn danger" onclick="quitGame()">çµæŸ</button>
        </div>
        <div id="feedback" class="feedback"></div>
        <div id="scorePop" class="score-pop"></div>`;

      app.innerHTML = html;
      updateTimerDisplay();
      updateScoreHUD(0);
    }

    function checkMatch() {
      if (selected.length < 2) return;
      const [a, b] = selected;

      const isPair = a.pairId != null && b.pairId != null &&
                     a.pairId === b.pairId && a.type !== b.type;

      let delta = 0;

      if (isPair) {
        correctCount++;
        showFeedback('correct');
        sounds.match.play();

        // æ­£ç¢ºï¼šé€£çºŒ +10, +20, +30...
        correctStreak += 1;
        wrongStreak = 0;
        if (correctStreak > maxCorrectStreak) maxCorrectStreak = correctStreak;
        delta = correctStreak * 10;
        score += delta;

        board[a.row][a.col] = null;
        board[b.row][b.col] = null;
        selected = [];

        setTimeout(() => {
          sounds.drop.play();
          board = dropTiles();
          board = refillTiles(board);
          renderBoard();
          updateScoreHUD(delta);

          if (board.flat().every(t => !t) && tilePool.length === 0) {
            endGame('æ‰€æœ‰å–®å­—å·²ç”¨å®Œ');
          }
        }, 250);
      } else {
        wrongCount++;
        showFeedback('wrong');
        sounds.wrong.play();

        // éŒ¯èª¤ï¼šå¦‚æœç•¶ä¸‹æ˜¯ 0 åˆ†ï¼Œç›´æ¥çµæŸ
        if (score === 0) {
          endGame('åˆ†æ•¸æ­¸é›¶');
          return;
        }

        // éŒ¯èª¤é€£çºŒæ‰£ 10, 20, 30...
        wrongStreak += 1;
        correctStreak = 0;
        delta = - wrongStreak * 10;
        score += delta;

        if (score <= 0) {
          score = 0;
          renderBoard();
          updateScoreHUD(delta);
          endGame('åˆ†æ•¸æ­¸é›¶');
          return;
        }

        setTimeout(() => {
          selected = [];
          renderBoard();
          updateScoreHUD(delta);
        }, 400);
      }
    }

    function startTimer() {
      gameActive = true;
      timeLeft = Number(selectedTime);
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          endGame();
        } else if (timeLeft <= 10) {
          sounds.countdown.play();
        }
      }, 1000);
    }

    function updateTimerDisplay() {
      const el = app.querySelector('.timer');
      if (!el) return;
      const m = String(Math.floor(timeLeft/60)).padStart(2,'0');
      const s = String(timeLeft%60).padStart(2,'0');
      el.textContent = `æ™‚é–“ï¼š${m}:${s}`;
      el.className = 'timer';
      if (timeLeft <= 10) el.classList.add('danger');
      else if (timeLeft <= 30) el.classList.add('warning');
    }

    function endGame(reason = 'æ™‚é–“åˆ°') {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      const acc = correctCount + wrongCount > 0
        ? Math.round(correctCount/(correctCount+wrongCount)*100)
        : 0;

      app.innerHTML = `
        <div class="game-over">
          <h1>Game Over! (${reason})</h1>
          <div class="stats">
            <span class="score-main">æœ€çµ‚å¾—åˆ†ï¼š${score}</span>
            <span>æ­£ç¢ºï¼š${correctCount} æ¬¡</span>
            <span>éŒ¯èª¤ï¼š${wrongCount} æ¬¡</span>
            <span>æ­£ç¢ºç‡ï¼š${acc}%</span>
            <span>æœ€é«˜é€£çºŒæ­£ç¢ºï¼š${maxCorrectStreak} é¡Œ</span>
          </div>
          <button class="btn big" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
          <button class="btn" onclick="renderLevelSelector()">å›åˆ°é¸å–®</button>
        </div>`;
    }

    function quitGame() {
      if (confirm('æå‰çµæŸï¼Ÿ')) endGame('æ‰‹å‹•çµæŸ');
    }

    function resetGame() {
      if (!currentLevel || !currentUnitStart) {
        renderLevelSelector();
        return;
      }
      if (timerId) clearInterval(timerId);
      initGame(currentLevel, currentUnitStart);
    }

    async function initGame(level, unitStart) {
      app.innerHTML = '<div class="loading">å–®å­—è¼‰å…¥ä¸­...</div>';
      const data = await loadCSV(level);
      const units = data.filter(d => d.unit >= unitStart && d.unit <= unitStart + 4);
      if (units.length < 8) {
        alert('å–®å­—ä¸è¶³ï¼è«‹é¸åˆ¥çµ„ unit');
        renderUnitSelector();
        return;
      }

      pairs = generatePairPool(units);
      if (pairs.length < (GRID_SIZE * GRID_SIZE) / 2) {
        alert('æˆå°å–®å­—ä¸è¶³ï¼');
        renderUnitSelector();
        return;
      }

      const initialPairCount = (GRID_SIZE * GRID_SIZE) / 2;
      const initialPairs = pairs.slice(0, initialPairCount);
      const remainingPairs = pairs.slice(initialPairCount);

      const initialTiles = initialPairs.flatMap(p => [p.wordTile, p.meaningTile]);
      board = createBoard(initialTiles);

      tilePool = shuffle(
        remainingPairs.flatMap(p => [p.wordTile, p.meaningTile])
      );

      selected = [];
      score = 0;
      correctCount = 0;
      wrongCount = 0;
      correctStreak = 0;
      wrongStreak = 0;
      maxCorrectStreak = 0;

      renderBoard();
      updateScoreHUD(0);
      startTimer();
    }

    function renderLevelSelector() {
      gameActive = false;
      if (timerId) clearInterval(timerId);
      timerId = null;

      app.innerHTML = `
        <div class="selector">
          <h2>é¸æ“‡ Level</h2>
          <div class="unit-group">
            ${[1,2,3,4,5,6].map(l =>
              `<button class="btn" onclick="currentLevel=${l};renderTimeSelector()">Level ${l}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    function renderTimeSelector() {
      app.innerHTML = `
        <button class="btn back-btn" onclick="renderLevelSelector()">è¿”å›</button>
        <div class="selector">
          <h2>é¸æ“‡æ™‚é–“</h2>
          <div class="time-group">
            ${Object.entries(TIME_OPTIONS).map(([s,label]) =>
              `<button class="btn ${selectedTime==s?'active':''}" onclick="selectedTime=${s};renderUnitSelector()">${label}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    function renderUnitSelector() {
      const groups = [];
      for (let i=1; i<=50; i+=5) groups.push({start:i, end:Math.min(i+4,50)});

      app.innerHTML = `
        <button class="btn back-btn" onclick="renderTimeSelector()">è¿”å›</button>
        <div class="selector">
          <h2>Level ${currentLevel} - é¸æ“‡ Unit ç¯„åœ</h2>
          <div class="unit-group">
            ${groups.map(g =>
              `<button class="btn" onclick="currentUnitStart=${g.start};initGame(currentLevel,${g.start})">${g.start} â€“ ${g.end}</button>`
            ).join('')}
          </div>
        </div>`;
    }

    renderLevelSelector();
  </script>
</body>
</html>
